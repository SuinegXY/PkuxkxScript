<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on 2015年 十一月 23日 星期一, 下午 9:05 -->
<!-- MuClient version 4.98 -->

<!-- Plugin "deep_bianli" generated by Plugin Wizard -->

<!--
简单的深度优先遍历插件
命令：sdbl 5 少林弟子
进行深度为5的深度优先遍历，寻找名为“少林弟子”的npc。
-->

<muclient>
<plugin
   name="deep_bianli"
   author="牛肉面"
   id="a9886d8241b72c38d16aa9ca"
   language="Lua"
   purpose="简单的深度优先遍历插件"
   save_state="y"
   date_written="2015-11-23 21:02:48"
   requires="4.98"
   version="1.0"
   >
<description trim="y">
<![CDATA[
深度优先遍历插件
示例：
sdbl 5 少林弟子
进行深度为5的深度优先遍历，寻找名为“少林弟子”的npc。
]]>
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
  <trigger
   group="bianli"
   match="^\s+这里.+的(出口|方向)有 (.+)$"
   name="get_exist"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>chukou="%2"
if string.find("%2","。") then
chukou = ExitFix(chukou);       
else
EnableTrigger("get_exists",1)
end
moved=1
EnableTrigger("get_exist",0)


</send>
  </trigger>
  <trigger
   group="bianli2"
   match="^(.*)。$"
   name="get_exists"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>chukou=chukou.."%1";
EnableTrigger("get_exists",0);
chukou = ExitFix(chukou);</send>
  </trigger>
  <trigger
   group="bianli"
   match="^\s+(.+)\((.+)\).*$"
   name="find_mubiao"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>if string.find("%1",mubiao)~=nil then
SetVariable("findmubiao",1)
Execute("follow "..string.lower("%2"))
end</send>
  </trigger>
  <trigger
   group="bianli"
   match="^[&gt; ]*设定环境变量：bianli\_wait \= \&quot;递减遍历深度\&quot;$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>require "wait"
wait.make( function()
if ck_i==1 and chukou_all_list[1][1]==nil then
 Note("结束遍历！")
 EnableGroup("bianli",0)
else
i=i+1
		 if math.fmod(i,"15") &lt; 1 then
            print("延时1秒后继续")      
            wait.time(1)
         end
 if tonumber(GetVariable("bl_finish"))==1 or tonumber(GetVariable("findmubiao"))==1 then 
       Note("say action 找到目标,遍历结束")
       EnableGroup("bianli",0)
  else
         if chukou_all_list[ck_i][1]==nil or dep==tonumber(maxcengshu) then
         Note("后退一步")
        
         dep=dep-1
         table.remove(chukou_all_list,ck_i)--删除此空记录
         ck_i=ck_i-1--应该走的方向列表
         fx=fx_back[1]
         Execute(fx..";set bianli_wait 递减遍历深度")   
         table.remove(fx_back,1)     
      
      else
         fx=chukou_all_list[ck_i][1]--当前房间出口的第一个方向
         Note("前进一步,当前层数"..dep..",当前步数 "..i)
         EnableTrigger("get_exist",1)
         Execute(fx..";set bianli_wait 深度遍历")
         dellj(chukou_all_list[ck_i],fx)
         dep=dep+1 
         ck_i=ck_i+1       
         fx_b=revfx(fx)
         table.insert(fx_back,1,fx_b)
       end
  end 
end
end)</send>
  </trigger>
  <trigger
   group="bianli"
   match="^[&gt; ]*设定环境变量：bianli\_wait \= \&quot;深度遍历\&quot;$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>require "wait"
wait.make( function()
  i=i+1
if math.fmod(i,"15") &lt; 1 then
    print("延时1秒后继续")      
    wait.time(1)
end
if i==1 then
   table.insert(chukou_all_list,chukou)
else
-- if fx~=nil and moved==1 then
--   table.insert(chukou_all_list,chukou)
--   local fx_b=revfx(fx)
--   dellj(chukou_all_list[ck_i],fx_b)
--   moved=0
-- end
	if moved==1 then
		if fx~=nil then
		table.insert(chukou_all_list,chukou)
        local fx_b=revfx(fx)
		dellj(chukou_all_list[ck_i],fx_b)
		moved=0	
	    end
	else
		Note("被拦路，放弃此出口！！")
		dep=dep-1
		ck_i=ck_i-1
	end
end  
if ck_i==1 and chukou_all_list[ck_i][1]==nil then
  Note("结束遍历！")
  EnableGroup("bianli",0)
else    
  if tonumber(GetVariable("bl_finish"))==1 or tonumber(GetVariable("findmubiao"))==1 then 
       Note("say action 找到目标,遍历结束")
       EnableGroup("bianli",0)
       --SetVariable("bl_finish","1")  
  else
      
      if chukou_all_list[ck_i][1]==nil or dep==tonumber(maxcengshu) then
         Note("后退一步")
        
         dep=dep-1
         table.remove(chukou_all_list,ck_i)--删除此空记录
         ck_i=ck_i-1--应该走的方向列表
         fx=fx_back[1]
         Execute(fx..";set bianli_wait 递减遍历深度")   
         table.remove(fx_back,1)     
      
      else
         fx=chukou_all_list[ck_i][1]--当前房间出口的第一个方向
         Note("前进一步,当前层数"..dep..",当前步数 "..i)

         EnableTrigger("get_exist",1)
         Execute(fx..";set bianli_wait 深度遍历")
         dellj(chukou_all_list[ck_i],fx)
         ck_i=ck_i+1
         dep=dep+1        
         fx_b=revfx(fx)
         table.insert(fx_back,1,fx_b)
       end
  end 
end
end)
 </send>
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   match="sdbloff"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>EnableGroup("bianli",0)</send>
  </alias>
  <alias
   match="^sdbl (\d)\s(\S+)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>EnableGroup("bianli",1)
maxcengshu="%1"
mubiao="%2"
chukou_all_list={}
fx_back={}
dep=0
ck_i=1
i=0
fx=nil
SetVariable("findmubiao",0)
Execute("look")
Send("set bianli_wait 深度遍历")</send>
  </alias>
</aliases>

<!--  Variables  -->

<variables>
  <variable name="maxcengshu">1</variable>
  <variable name="findmubiao">1</variable>
</variables>

<!--  Script  -->


<script>
<![CDATA[
function revfx(fx)

       if fx=="enterbj" then return "outbj"    end
       if fx=="outbj" then return "enterbj"    end
       if fx=="swboxiaolu" then return "boxiaolune"    end
       if fx==nil then return     end
       if fx=="south" then return "north"    end
       if fx=="east" then return "west"   end
       if fx=="west" then return "east"   end
       if fx=="north" then return "south"   end
       if fx=="southup" then return "northdown"   end
       if fx=="southdown" then return "northup"   end
       if fx=="westup" then return "eastdown"   end
       if fx=="westdown" then return "eastup"   end
       if fx=="eastup" then return "westdown"   end
       if fx=="eastdown" then return "westup"   end
       if fx=="northup" then return "southdown"   end
       if fx=="northdown" then return "southup"   end
       if fx=="northwest" then return "southeast"   end
       if fx=="northeast" then return "southwest"   end
       if fx=="southwest" then return "northeast"   end
       if fx=="southeast" then return "northwest"   end
       if fx=="enter" then return "out"   end
       if fx=="out" then return "enter"   end
       if fx=="up" then return "down"   end
       if fx=="down" then return "up"   end

       if fx=="u" then return "d"   end
       if fx=="d" then return "u"   end
       if fx=="s" then return "n"    end
       if fx=="e" then return "w"   end
       if fx=="w" then return "e"   end
       if fx=="n" then return "s"   end
       if fx=="su" then return "nd"   end
       if fx=="sd" then return "nu"   end
       if fx=="wu" then return "ed"   end
       if fx=="wd" then return "eu"   end
       if fx=="eu" then return "wd"   end
       if fx=="ed" then return "wu"   end
       if fx=="nu" then return "sd"   end
       if fx=="nd" then return "su"   end
       if fx=="nw" then return "se"   end
       if fx=="ne" then return "sw"   end
       if fx=="sw" then return "ne"   end
       if fx=="se" then return "nw"   end
       return fx
end

ExitFix = function(strExit)
        strExit = Replace(strExit, "、", ";", ture);
	strExit = Replace(strExit, " 和 ", ";", ture);
	strExit = Replace(strExit, "。", "", ture);
        strExit = Replace(strExit, " ", "", ture);
	local tNewExits = {};
        local tExits = utils.split(strExit,";");
        local tFullExits = {"up","down","south","east","west","north","southup","southdown","westup","westdown","eastup","eastdown","northup","northdown","northwest","northeast","southwest","southeast","enter","out"}
        for i = 1, table.getn(tFullExits) do
               for j = 1, table.getn(tExits) do
                     if string.len(tFullExits[i]) == string.len(tExits[j]) then
                           local strRightExit = tFullExits[i]
                           local strCheckExit = tExits[j]
			   for o = 1,string.len(strRightExit) do
				if string.find(strRightExit, string.sub(tExits[j],o,o)) then
                                      strCheckExit = string.gsub(strCheckExit, string.sub(tExits[j],o,o), "")
                                end
                           end
                           if strCheckExit == "" then
				table.insert(tNewExits, strRightExit);
			   end
                     end
               end
        end

	local strCorrectExit = "";
	for i, v in pairs(tNewExits) do
		if strCorrectExit ~= "" then
			strCorrectExit = strCorrectExit .. ";";
		end
	    strCorrectExit = strCorrectExit .. tNewExits[i];
	end

        return utils.split(strCorrectExit,";");
end

function dellj(nowlj,fx)

   local fx=fx
   local nowlj=nowlj
   local i=1
   if fx==nil then return 
   else for i=1,table.getn(nowlj) do
           if nowlj[i]==fx then table.remove(nowlj,i) end
          i=i+1 
        end
   end
end
]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="deep_bianli:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
